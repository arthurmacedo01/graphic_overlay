<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>
      IGC Relative Height Plot and Ground Velocity Display with Animation
    </title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <style>
      body {
        background-color: black;
      }
      .chart-container {
        margin: 20px;
        width: 300px;
        display: flex;
        align-items: center;
      }
      #velocityDisplay {
        font-size: 24px;
        color: rgba(255, 255, 255, 1);
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <input type="file" id="fileInput" />
    <label for="ignoreSeconds">Ignore first n seconds: </label>
    <input type="number" id="ignoreSeconds" value="0" min="0" />
    <button id="generateButton">Generate Charts</button>
    <div class="chart-container">
      <canvas id="heightChart"></canvas>
    </div>
    <div class="chart-container">
      <div id="velocityDisplay">0 km/h</div>
    </div>
    <div class="chart-container">
      <canvas id="completeChart"></canvas>
    </div>
    <div class="chart-container">
      <canvas id="velocityChart"></canvas>
    </div>

    <script>
      let fileContents = "";

      document
        .getElementById("fileInput")
        .addEventListener("change", function (event) {
          const file = event.target.files[0];
          const reader = new FileReader();

          reader.onload = function (event) {
            fileContents = event.target.result;
          };

          reader.readAsText(file);
        });

      document
        .getElementById("generateButton")
        .addEventListener("click", function () {
          if (!fileContents) {
            alert("Please select a file first.");
            return;
          }

          const { times, latitudes, longitudes, altitudes } =
            parseIGC(fileContents);
          const relativeHeightData = calculateRelativeHeight(altitudes);
          const timeDiffs = calculateTimeDiffs(times);
          const velocities = calculateVelocities(
            latitudes,
            longitudes,
            timeDiffs
          );

          const ignoreSeconds = parseInt(
            document.getElementById("ignoreSeconds").value,
            10
          );
          const ignoreMilliseconds = ignoreSeconds * 1000;

          let ignoredTime = 0;
          let startIndex = 0;

          while (
            ignoredTime < ignoreMilliseconds &&
            startIndex < timeDiffs.length
          ) {
            ignoredTime += timeDiffs[startIndex];
            startIndex++;
          }

          const adjustedTimesAll = times.map((time, i) => {
            const baseTime = times[0];
            return timeToSeconds(time) - timeToSeconds(baseTime);
          });

          const baseTimeAnimated = times[startIndex]; // New base time for relative calculation
          const adjustedTimesAnimated = times.slice(startIndex).map((time) => {
            return timeToSeconds(time) - timeToSeconds(baseTimeAnimated);
          });

          plotCompleteChart(adjustedTimesAll, relativeHeightData);
          plotVelocityChart(adjustedTimesAll.slice(1), velocities); // Adjusted for the velocity chart
          animatePlot(
            adjustedTimesAnimated,
            relativeHeightData.slice(startIndex),
            timeDiffs.slice(startIndex),
            velocities.slice(startIndex)
          );
        });

      function parseIGC(contents) {
        const lines = contents.split("\n");
        const times = [];
        const latitudes = [];
        const longitudes = [];
        const altitudes = [];

        lines.forEach((line) => {
          if (line.startsWith("B")) {
            const time = line.slice(1, 7); // HHMMSS format
            const latitude = convertToDecimalDegrees(
              line.slice(7, 15),
              line[15]
            );
            const longitude = convertToDecimalDegrees(
              line.slice(16, 25),
              line[25]
            );
            const altitude = parseInt(line.slice(30, 35), 10); // Adjust indices based on actual IGC file format
            times.push(time);
            latitudes.push(latitude);
            longitudes.push(longitude);
            altitudes.push(altitude);
          }
        });

        return { times, latitudes, longitudes, altitudes };
      }

      function convertToDecimalDegrees(coordinate, direction) {
        const degrees = parseInt(coordinate.slice(0, 2), 10);
        const minutes = parseFloat(coordinate.slice(2)) / 1000;
        let decimalDegrees = degrees + minutes / 60;
        if (direction === "S" || direction === "W") {
          decimalDegrees = -decimalDegrees;
        }
        return decimalDegrees;
      }

      function calculateRelativeHeight(altitudeData) {
        const landingAltitude = altitudeData[altitudeData.length - 1];
        return altitudeData.map((altitude) => altitude - landingAltitude);
      }

      function calculateTimeDiffs(times) {
        const timeDiffs = [];

        function timeToSeconds(time) {
          const hours = parseInt(time.slice(0, 2), 10);
          const minutes = parseInt(time.slice(2, 4), 10);
          const seconds = parseInt(time.slice(4, 6), 10);
          return hours * 3600 + minutes * 60 + seconds;
        }

        for (let i = 1; i < times.length; i++) {
          const prevTime = timeToSeconds(times[i - 1]);
          const currTime = timeToSeconds(times[i]);
          timeDiffs.push((currTime - prevTime) * 1000); // Convert to milliseconds
        }

        return timeDiffs;
      }

      function calculateVelocities(latitudes, longitudes, timeDiffs) {
        const velocities = [];

        function haversine(lat1, lon1, lat2, lon2) {
          const R = 6371e3; // metres
          const φ1 = (lat1 * Math.PI) / 180;
          const φ2 = (lat2 * Math.PI) / 180;
          const Δφ = ((lat2 - lat1) * Math.PI) / 180;
          const Δλ = ((lon2 - lon1) * Math.PI) / 180;

          const a =
            Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

          return R * c; // in metres
        }

        for (let i = 1; i < latitudes.length; i++) {
          const distance = haversine(
            latitudes[i - 1],
            longitudes[i - 1],
            latitudes[i],
            longitudes[i]
          );
          const timeDiffHours = timeDiffs[i - 1] / (1000 * 60 * 60); // Convert milliseconds to hours
          const velocity = distance / 1000 / timeDiffHours; // km/h
          velocities.push(velocity);
        }

        return velocities;
      }

      function timeToSeconds(time) {
        const hours = parseInt(time.slice(0, 2), 10);
        const minutes = parseInt(time.slice(2, 4), 10);
        const seconds = parseInt(time.slice(4, 6), 10);
        return hours * 3600 + minutes * 60 + seconds;
      }

      function plotCompleteChart(times, data) {
        const ctx = document.getElementById("completeChart").getContext("2d");
        new Chart(ctx, {
          type: "line",
          data: {
            labels: times,
            datasets: [
              {
                label: "Relative Height (Complete)",
                data: data,
                borderColor: "rgba(255, 255, 255, 1)",
                borderWidth: 1,
                fill: false,
                pointRadius: 3,
                pointBackgroundColor: "rgba(255, 255, 255, 1)",
                pointBorderColor: "rgba(255, 255, 255, 1)",
              },
            ],
          },
          options: {
            plugins: {
              legend: {
                display: true,
                position: "top",
              },
              datalabels: {
                display: false,
              },
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Time (s)",
                },
              },
              y: {
                title: {
                  display: true,
                  text: "Height (m)",
                },
              },
            },
          },
        });
      }

      function plotVelocityChart(times, velocities) {
        const ctx = document.getElementById("velocityChart").getContext("2d");
        new Chart(ctx, {
          type: "line",
          data: {
            labels: times,
            datasets: [
              {
                label: "Ground Velocity (Complete)",
                data: velocities,
                borderColor: "rgba(192, 75, 75, 1)",
                borderWidth: 1,
                fill: false,
                pointRadius: 3,
                pointBackgroundColor: "rgba(192, 75, 75, 1)",
                pointBorderColor: "rgba(192, 75, 75, 1)",
              },
            ],
          },
          options: {
            plugins: {
              legend: {
                display: true,
                position: "top",
              },
              datalabels: {
                display: false,
              },
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Time (s)",
                },
              },
              y: {
                title: {
                  display: true,
                  text: "Velocity (km/h)",
                },
              },
            },
          },
        });
      }

      function animatePlot(times, data, timeDiffs, velocities) {
        const ctx = document.getElementById("heightChart").getContext("2d");
        const chart = new Chart(ctx, {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: "Relative Height",
                data: [],
                borderColor: "rgba(255, 255, 255, 1)",
                borderWidth: 2,
                fill: false,
                pointRadius: [],
                pointBackgroundColor: [],
                pointBorderColor: [],
              },
            ],
          },
          options: {
            layout: {
              padding: {
                top: 20,
                right: 120,
                bottom: 20,
                left: 20,
              },
            },
            plugins: {
              legend: {
                display: false, // Hide the legend
                position: "top",
              },
              datalabels: {
                align: "right",
                anchor: "end",
                color: "rgba(255, 255, 255, 1)",
                font: {
                  weight: "bold",
                  size: 18,
                },
                formatter: function (value, context) {
                  return context.dataIndex === context.dataset.data.length - 1
                    ? value + " m"
                    : "";
                },
              },
            },
            scales: {
              x: {
                display: false, // Hide the entire x-axis and all labels
              },
              y: {
                grid: {
                  display: false, // Hide grid lines on the y-axis
                },
                title: {
                  display: false,
                  text: "Height (m)",
                },
              },
            },
          },
          plugins: [ChartDataLabels],
        });

        let index = 0;

        function addDataPoint() {
          if (index < times.length) {
            chart.data.labels.push(times[index]);
            chart.data.datasets[0].data.push(data[index]);

            // Default color and size for points
            chart.data.datasets[0].pointBackgroundColor.push(
              "rgba(255, 255, 255, 1)"
            );
            chart.data.datasets[0].pointBorderColor.push(
              "rgba(255, 255, 255, 1)"
            );
            chart.data.datasets[0].pointRadius.push(3);

            // Highlight the current point
            if (index > 0) {
              chart.data.datasets[0].pointBackgroundColor[index - 1] =
                "rgba(255, 255, 255, 1)";
              chart.data.datasets[0].pointBorderColor[index - 1] =
                "rgba(255, 255, 255, 1)";
              chart.data.datasets[0].pointRadius[index - 1] = 3;
            }

            chart.data.datasets[0].pointBackgroundColor[index] =
              "rgba(255, 255, 255, 1)";
            chart.data.datasets[0].pointBorderColor[index] =
              "rgba(255, 255, 255, 1)";
            chart.data.datasets[0].pointRadius[index] = 10;

            // Update the velocity display
            if (index < velocities.length) {
              document.getElementById(
                "velocityDisplay"
              ).innerText = `${velocities[index].toFixed(2)} km/h`;
            }

            chart.update();
            index++;
            if (index < times.length) {
              setTimeout(addDataPoint, timeDiffs[index - 1]);
            }
          }
        }

        addDataPoint();
      }
    </script>
  </body>
</html>
